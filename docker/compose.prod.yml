x-app-image: &app_image ${APP_IMAGE}:${APP_TAG}
x-app-env: &app_env ["../.env"]
name: spotacus

services:
    app:
        image: *app_image
        restart: unless-stopped
        env_file: *app_env
        environment:
            APP_ENV: production
            APP_DEBUG: ${APP_DEBUG:-false}
        volumes:
            - ../storage:/var/www/html/storage
            # named volume so nginx sees the same built files
            - public-build:/var/www/html/public
        depends_on:
            mysql:
                condition: service_healthy
            redis:
                condition: service_started
        networks: [appnet]
        healthcheck:
            test: ["CMD-SHELL", "SCRIPT_NAME=/ping REQUEST_METHOD=GET cgi-fcgi -bind -connect 127.0.0.1:9000 || exit 1"]
            interval: 20s
            timeout: 5s
            retries: 10
        logging:
            driver: "json-file"
            options: { max-size: "10m", max-file: "5" }

    # Optional: separate queue worker
    queue:
        image: *app_image
        restart: unless-stopped
        env_file: *app_env
        depends_on:
            mysql:
                condition: service_healthy
            redis:
                condition: service_started
        command: >
            sh -lc "php artisan queue:work redis
                    --sleep=1
                    --tries=3
                    --max-time=3600
                    --timeout=120
                    --backoff=3"
        healthcheck:
            disable: true
        networks: [appnet]
        logging:
            driver: "json-file"
            options: { max-size: "10m", max-file: "5" }

    # Optional: lightweight scheduler loop
    scheduler:
        image: *app_image
        restart: unless-stopped
        env_file: *app_env
        depends_on:
            mysql:
                condition: service_healthy
            redis:
                condition: service_started
        command: >
            sh -lc "while :; do php artisan schedule:run --no-interaction || true; sleep 60; done"
        healthcheck:
            disable: true
        networks: [appnet]
        logging:
            driver: "json-file"
            options: { max-size: "10m", max-file: "5" }

    nginx:
        image: nginx:alpine
        restart: unless-stopped
        ports:
            - "80:80" # ACME + redirect
            - "443:443" # HTTPS
        volumes:
            - public-build:/var/www/html/public:ro
            - ./nginx/nginx.prod.conf:/etc/nginx/conf.d/default.conf:ro
            - ./certbot/letsencrypt:/etc/letsencrypt:ro
            - certbot-htdocs:/var/www/certbot
        depends_on:
            app:
                condition: service_healthy
        networks: [appnet]
        healthcheck:
            test: ["CMD-SHELL", "nginx -t || exit 1"]
            interval: 30s
            timeout: 5s
            retries: 5
        logging:
            driver: "json-file"
            options: { max-size: "10m", max-file: "5" }

    mysql:
        image: mysql:8
        restart: unless-stopped
        environment:
            MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
            MYSQL_DATABASE: ${DB_DATABASE}
            MYSQL_USER: ${DB_USERNAME}
            MYSQL_PASSWORD: ${DB_PASSWORD}
        command:
            - --character-set-server=utf8mb4
            - --collation-server=utf8mb4_unicode_ci
            - --skip-log-bin
        volumes:
            - mysql-prod-data:/var/lib/mysql
        healthcheck:
            test: ["CMD", "mysqladmin", "ping", "-h", "127.0.0.1", "-p${DB_ROOT_PASSWORD}"]
            interval: 10s
            timeout: 5s
            retries: 10
        networks: [appnet]
        logging:
            driver: "json-file"
            options: { max-size: "10m", max-file: "5" }

    redis:
        image: redis:7-alpine
        restart: unless-stopped
        networks: [appnet]
        logging:
            driver: "json-file"
            options: { max-size: "10m", max-file: "5" }

    cloudflared:
        image: cloudflare/cloudflared:latest
        restart: unless-stopped
        networks: [appnet]
        # volumes:
        #     - ./cloudflared/config.yaml:/etc/cloudflared/config.yaml:ro
        command:
            - tunnel
            - --no-autoupdate
            - run
            - --token
            - ${CLOUDFLARE_TUNNEL_TOKEN}
        logging:
            driver: json-file
            options:
                max-size: "10m"
                max-file: "5"

    # One-shot helper (run with --profile certbot)
    certbot:
        image: certbot/certbot
        container_name: certbot
        volumes:
            - ./certbot/letsencrypt:/etc/letsencrypt
            - certbot-htdocs:/var/www/certbot
        profiles: ["certbot"]

    # Autorene w + hot reload (opt-in)
    certbot-renewer:
        image: certbot/certbot
        restart: unless-stopped
        volumes:
            - ./certbot/letsencrypt:/etc/letsencrypt
            - certbot-htdocs:/var/www/certbot
        entrypoint: /bin/sh
        command: -lc ' while :; do certbot renew --deploy-hook "sh -lc '\''docker compose exec -T nginx nginx -s reload || true'\''"; sleep 12h; done'
        profiles: ["certbot"]

networks:
    appnet: {}

volumes:
    mysql-prod-data:
    certbot-htdocs:
    public-build:
